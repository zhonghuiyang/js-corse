<h3 align="center">函数</h3>
------

#### 一、作用域

**1、作用域**

​      什么是作用域，变量在函数内部作用的范围／区域。有函数的地方就有作用域



**2、全局作用域和局部作用域**

```css
全局变量:可以在函数内部和函数外部使用的变量，就是"全局变量"。

在函数外部定义的变量，就是"全局变量"。

"全局变量"即可以在函数外使用，也可以在函数内部使用。

"全局变量"在网页关闭时，自动消失(释放空间)。

总结：在函数外部定义的变量，就是全局作用域


局部变量：只能在函数内部使用的变量，称为"局部变量"。

"局部变量"在函数内部定义，在函数内使用。

"局部变量"在函数外部无法访问。

"局部变量"在函数执行完毕就消失了。

总结：在函数内部定义的变量，就是局部作用域


在函数内部，省略关键字var定义的变量是"全局变量"。

注意：var关键字尽量别省略，省略后"全局变量"和"局部变量"容易搞混淆。

定义变量都使用var
```



**3、作用域链**

- 全局作用域我们义称之为0级作用域
- 定义函数开启的作用域就是1级 - 2级 - 3级。。。作用城
- JavaScript会将这些作用域链接在起形成个链条， 这个链条就是作用域链0--1---2---3---4

  



**4、变量在作用域查找规则**

- 先在当前找，找到就使用当前作用域找到的
- 如果当前作用域中没有找到，就去上一级作用域中查找
- 以此类推直到0级为止，如果0级作用域还没找到，就报告错



**5、变量的生命周期**

- JavaScript 变量生命周期在它声明时初始化。

- 局部变量在函数执行完毕后销毁。

- 全局变量在页面关闭后销毁





#### 二、预解析 

**1、什么是预解析?**

```
浏览器在执行JS代码的时候会分成两部分操作:预解析以及逐行执行代码。也就是说浏览器不会直接执行代码，而是加工处理之后再执行，这个加工处理的过程，我们就称之为预解析
```

**2、预解析规则** - 变量提升

- <font color="red">将变量声明和函数声明提升到当前作用域最前面</font>
- <font color="red">将剩余代码按着书写顺序依次放到后面</font>



**3、预解析补充**

把一个函数赋值给变量(var声明的), 函数声明不会提升

```js

```



#### 三、JS的编译和执行

1、先检查语法错误－－－语法错误，当前代码段不执行

2、声明提升－－－－－－变量提升和函数提升，作用域内所有使用var声明的变量和非匿名函数

3、开始编译－－－－－－逐行执行









#### 四、拷贝传值和引用传址

**1、拷贝传值**：将一个变量的值"拷贝"一份，传给了另一个变量

```js
var a=10;//声明变量

var b=a;//将变量a的值"拷贝"一份，赋给变量b

a=100；   //重新给变量赋值100

alert(b);//10

alert(a);//100
```

拷贝传值：基本数据类型都是"拷贝传值"。

拷贝传值，就是将一个变量的值"拷贝"一份，传给了另一个变量。也可以说是复制。

拷贝传值中，两个变量之间没有任何联系，修改其中一个变量的值，另一个不会改变。

这两个变量之间，是相互独立的，没有任何联系。

基本数据类型存在"快速内存"（也叫栈内存）中的。因为，基本数据类型只有一个变量名和一个变量值。



**2、引用传址**：复合数据类型都是"引用传地址"

复合数据类型的存储分两步：

a、将变量名和数据地址存"快速内存"（也叫栈内存）中。

b、具体的数据存在"慢内存"（也叫堆内存）中。

引用传址：将一个变量的数据地址，"拷贝"一份，传给了另一个变量。这两个变量，指向"同一个地址"。

大家共享同一份数据。

如果其中一个变量的值发生了改变，那么，另一个变量的值也得变。要变一起变。

因此，这两个变量是有联系的，要变大家一起变。

```js
var arr1["张三",24,"本科"];

var arr2=arr1;//将arr1的地址，"拷贝"一份，传给了另一个变量arr2

arr[1]=30;    //给变量arr[1]重新赋值30

alert(arr2[1]);//arr2[1]=30
```



栈区（stack）

堆区（heap）



#### 五、递归

我们都知道，一个函数可以调用其他函数。**如果这个函数在内部调用它自己，那么这个函数就叫递归函数。**

特点： 

1：在函数里面调用自身。 

2：必须有一个明确的递归结束条件，这个称之为递归出口。 

3：不确定循环执行的次数。 



缺点：使用递归函数一定要注意，处理不当就会进入死循环。在实际使用中，递归函数由于消耗时间比较长（相比for循环和while循环），所以很少使用。

举个例子： 你用你手中的钥匙打开一扇门，结果去发现前方还有一扇门，紧接着你又用钥匙打开了这扇门，然后你又看到一扇们...但是当你开到某扇门时，发现前方是一堵墙无路可走了，你选择原路返回——这就是递归



1、求Fibonacci的第n个数  1 1 2 3 5 8 13 21...（该数列中，有n个数字，从第三个数字开始：数值 =前一个数字 + 前面一个数字）即，n=(n-2)+(n-1)

```js
function f1 (n) {

    if (n == 1) return 1;
    if (n == 2) return 1;

    return f1(n-1) + f1(n-2);
}

console.log(f1(7));
```

2、求n个数的累加

```js
function getSum (n) {
    
    if (n == 1) { return 1;}
    return n + getSum(n - 1);
}

console.log(getSum(100));

```

3、求n的阶乘？   n!  =  n * (n-1) !;

```js
function f(num){ 
    if(num<1){ 
    	return 1; 
    }
   	return f(num-1)*num; 
} 

```

